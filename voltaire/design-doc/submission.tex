\newpage
\section{Proposal Submission}
\label{sect:submission}

Proposals are submitted by a member of a submitter group.  They must be counter-signed by a quorum of submitter keys, where the quorum is specified by the \texttt{ProposalQuorum} parameter.
%\khcomment{Difficult question: who controls registration/de-registration of submitter keys.}\pkcomment{How about an on-chain vote by ada holders?}\khcomment{That isn't possible without extending the design, of course...  You could include this as an update proposal, of course, but who submits the proposal and how do you avoid the submitter group then vetoing changes?}\khcomment{How do we
%ensure that there are always enough submitters in existence.}\pkcomment{We should have an option to reboot this set by a vote from ada holders, in case there are not enough (active) submitters}\khcomment{The
%quorum may be a protocol parameter.}\pkcomment{with an enforced sensible range in $(0,1)$}\khcomment{Yes.  I was expecting an integer value, though.  Consider the edge case where there are only a few submitters, or awkward cases where the number of submitters changes. Do you round up or down?}  No fee is charged for proposal
%submission.\khcomment{This may need to be discussed.}
A submitter may submit any number of proposals in a single epoch.
%\khcomment{This assumes that submitters are trustworthy and will not collectively spam the blockchain.  One possible solution is to use percentage of voting stake to choose the composition of this group as a subset of the delegator group.  Doing so removes one balance in the system, however (delegates propose the business that they will vote on, so potentially creating a power bloc).}
%\pkcomment{Depending on how we accumulate the counter signatures (including all of them in the transaction with the proposal, which requires off chain coordination between the submitters, or collecting them in susequent transactions) it might also be possible for a single submitter to spam the chain}
%\khcomment{The obvious approach is to use multi-sig transactions, or similar.  That would prevent multiple proposals from spamming the chain [you might be able to resubmit the same proposal, of course].  Requiring multiple transactions would be more problematic.}
It is assumed that the submitter group acts honestly on behalf of the stakeholders, and will not act to ``spam'' the chain with proposals or to prevent progress.  Suitable governance mechanisms must also be put in place to ensure that it is not possible for an unrepresentative ``cabal'' to gain control of the blockchain.

\subsection{Format}

Each proposal has a header and a body.  % and must be signed\khcomment{Submitting may implicitly sign the proposal?}.

\paragraph{Header.} The header must include:

\begin{verbatim}
"header": {
  "linked"           : ProposalHash,
  "voteby"           : Slot,
  "votethreshold"    : Threshold,
  "endorseby"        : Optional Slot,
  "endorsethreshold" : Optional Threshold,
  "enact"            : Epoch,
  "submitter"        : KeyHash
}
\end{verbatim}% \pkcomment{Do we need \texttt{Slot}, or \texttt{Epoch}?}\khcomment{You want Slot, because that is what matters for consistent voting [I assume you want the current speed of enactment]}

The \texttt{linked} field allows the proposal to be linked with the previous off-chain or on-chain acceptance (see Appendix~\ref{sect:relating-off-and-on-chain} and Section~\ref{sect:proposalid}), so enabling a chain of approval.  The \texttt{voteby} and \texttt{endorseby} fields specify deadlines.
Votes and endorsements must be received prior to the specified slot if they are to be counted.  The endorsement deadline is only required for protocol version upgrades.
%\khcomment{Arguably, to avoid performance issues, tallying should either happen at epoch boundaries or in a separate thread.}\pkcomment{Yes, same as for calculating the stake distribution and the rewards}
To avoid performance issues, tallying must be spread over time, eg in a separate thread or using a ``pulsing'' calculation. % \pkcomment{Yes, same as for calculating the stake distribution and the rewards}
In order to avoid zombie proposals that could disrupt operations, deadlines must be set within a reasonable time period after submission (e.g. within 3 epochs).
Voting and endorsement slots and thresholds are completely independent, so a voting deadline may be set before/after/at the same time as an endorsement deadline.
Deadlines can never be set in the past.
The deadline for proposal enactment must be later than the  voting and endorsement deadlines, and account for required stability windows.
%
The \texttt{votethreshold} and \texttt{endorsethreshold} fields allow specific thresholds to be set for voting and endorsement, respectively.  This allows the type of proposal to be differentiated on a per-proposal basis
(e.g. a protocol version upgrade may require a higher vote threshold than a simple parameter change)
\footnote{Arguably, this is dangerous and standard or minimum thresholds should be set as protocol parameters.}.
%
The \texttt{enact} field specifies when the proposal is to be enacted if it is approved and endorsed.  This will always be in the future.
%
The proposal submitter must belong to the correct submitter group.  \footnote{It would be possible to support
  different groups for each kind of proposal.}

The body of the proposal is specific to the proposal type.

% \newpage
\paragraph{Parameter Update Body.}  The proposal format is identical to that used for Shelley/Allegra/Mary/Alonzo. \TODO{Check the concrete format.}  Multiple parameters may be changed in a single proposal if required.
All parameters in a proposal must comply with \emph{validity} rules both on submission and on enactment.
% Parameters are checked for validity on enactment, rather than on submission, so it is possible to submit a proposal that will change parameters following a future protocol version upgrade, for example.
% \khcomment{Consider this carefully. We do need to allow initial parameters to be set.}


\begin{verbatim}
"body": {
  "parameter n" : "new value 1",
  ...
  "parameter n" : "new value n"
}
\end{verbatim}

\paragraph{Protocol Version Upgrade Body.}  The format is slightly changed from that used for Shelley/Allegra/Mary/Alonzo.


\begin{verbatim}
"body": {
  "Major"       : Integer,
  "Minor"       : Integer,
  "Genesis"     : Hash,
  "CodeVersion" : [Hash]
}
\end{verbatim}

The major and minor protocol version numbers identify the new protocol.  The genesis parameter hashes the genesis file, so ensuring that consistent initial protocol parameters are used.
The proposal also includes a list of hashes that can be used to identify one or more reference versions of the node software that implement the new protocol (e.g. as references to a specific git commit).
Node operators are not required to use one of these versions -- any software that follows the protocol rules may be be used
\footnote{Recommended software versions could also be included in the genesis file if desired.}.
% Node software only needs to comply with the new protocol rules.  It does not need to be a specific version, for example, and we do not check a software hash.
% \khcomment{I assume that
The initial set of protocol parameters is encoded in the genesis hash.

% \khcomment{We might also need to include some hash here that can be verified by the system?} % Dealt woth

\paragraph{Central Funds Transfer Body.}  The format is also identical to that used for Shelley/Allegra/Mary/Alonzo.
A single proposal may cover multiple funds transfers.  These are enacted in the order they are encountered.
% \khcomment{There is a tradeoff here: submit many proposals that may clog up the system, or submit a few.  Even if there are fewer proposals, transaction size limits mean
% that a set of transfers (for Catalyst funds, for instance), may  need to broken down into a large number of submission.}

\begin{verbatim}
"body": {
  "from"      : "Treasury"/"Reserves",
  "to"        : Optional "Treasury"/"Reserves",
  "toAddress" : Optional Address,
  "amount"    : Nat
}
\end{verbatim}

Funds may be transferred from either the treasury or the reserves, and sent to either an address, or to the treasury/reserves.
Transfers from treasury to treasury or from reserves to reserves are not permitted.  All transfers must be for a positive amount (including zero, which might be required for accounting or automation reasons). %\pkcomment{Why do we want to allow zero here?})\khcomment{I was assuming that this might be needed for accounting or automation reasons}.
Multiple transfers may be made in a single epoch.  This allows for proper accounting, where e.g. different kinds of transfer must
be authorised by different groups.

Errors in transfers between reserves and treasury, or vice-versa, may be corrected by constructing a reverse transfer that cancels the original error.
This cannot happen for transfers to addresses.  Any errors in such transfers, must be corrected by the owner of the address, who must either explicitly transfer
the funds to reserves or treasury, or else transfer the funds to a holding account\footnote{Note that there is currently no way to transfer funds back to treasury/reserves.}
Note that ledger rules ensure that the treasury and reserves may never decrease below zero (even temporarily), so that a ``double-spending attack'' is not possible.
% \khcomment{Jared to confirm.}

\subsection{Proposal Signing}

All proposals must be signed when they are submitted.  A proposal must be counter-signed by a quorum of signatures using a signing
policy that conforms to the existing \emph{multi-sig} transaction mechanism.  This enables the use of standard transaction witnessing.
% where the quorum is a protocol parameter
The signing policy is then provided as an updatable protocol parameter.  This gives a great deal of flexibility to define and change submission policies.
To reduce the possibility of abuse, the policy must comply with a minimum quorum size, which must be hard-wired into the protocol as a non-updatable
parameter.
Note that limits on transaction size will limit the maximum quorum size (currently to around 500 signatories).


%\khcomment{The obvious approach is to use transaction witnessing and a multi-sig approach, as described here.  That implies a change to the submission process, and also that
%  the submitter group is sufficiently small to allow this (I think we calculated n+m=500, where n is the actual number and m is the required number?}
% \khcomment{Using multi-sig potentially allows policies to be defined as described above.  This simplifies the system by removing the need for a separate Elector group,
%  but is perhaps open to abuse of power?}

Note that the process described here intrinsically supports automation.  Signatories can be automated agents if desired rather than individuals.  This also allows integration into a full on-chain voting mechanism in the longer term, e.g. by adopting the PriviLedge mechanisms.  The outcome of an off-chain or on-chain vote may be to construct a signed on-chain proposal for subsequent enactment.  Ultimately, if the process is purely on-chain, then the vote outcome could be embedded as the authorisation for the proposal submission without needing to construct or maintain special submitter keys.  This would improve some aspects of security, but would mean that either: i) a proposal would need to be formalised prior to the initial voting round (which might be impractical for e.g. protocol upgrades or some forms of funds transfers); or else ii) delegates would need to confirm that the proposal that was enacted was equivalent to the one that was originally agreed.


\subsection{Proposal Identifiers}
\label{sect:proposalid}

Each proposal has a unique identifier that is used for voting, endorsement, and enactment.  It may also be used to refer to the proposal in the off-chain process (eg to provide its
status, encourage voting, etc).  At a minimum, uniqueness must be enforced between submission and enactment, but it will be simplest to have full uniqueness, since the blockchain will need to record
details of each proposal indefinitely.

There are three obvious ways to construct an identifier.

\begin{description}
\item
  [Option 1.]
  An explicit identifier that is included in the proposal submission.  This could be tied, if desired, directly to the off-chain proposal/discussion.
  Care needs to be taken to ensure uniqueness of any manually assigned proposal identifier.  This is shown above as the \texttt{proposal} field.
\item
  [Option 2.]
  The identifier is constructed by hashing the submitted proposal.  This allows proposals to be identified before submission as well as during voting and enactment.  This property may be
  useful to connect off-chain and on-chain mechanisms for example.  \emph{Collision resistance} is required for the hash. % \khcomment{Confirm this.}  Confirmed.
\item
  [Option 3.]
  The transaction identifier is used to identify the proposal.  This has the advantage that it is already available on-chain, and is guaranteed to be unique.  However, it cannot be
  referred to prior to on-chain proposal submission.  Moreover, the transaction identifier cannot be relied on until the chain is stable, potentially creating confusion/an opportunity for attack.  \emph{Security cincerns therefore rule this option out.}
\end{description}

It is proposed to use Option 2, but to also include an explicit reference.  This allows
the formal proposal to be linked to off-chain or on-chain discussions and/or votes.
The reference does necessarily not need to be unique -- a single discussion or outline vote could
lead to multiple on-chain proposals.

\subsection{Proposal Validity Rules}
\label{sect:validity}

A proposal is checked for validity at two points:
\begin{enumerate}
\item
  on submission;
\item
  on enactment.
\end{enumerate}

Invalid proposals are immediately rejected and never enacted.

A proposal is \emph{valid} if it satisfies all of the following conditions:

\begin{enumerate}
\item
  it is syntactically well-formed;
\item
  all parameter values are within permitted ranges (e.g. all funds transfers are positive);
\item
  it has been (counter-)signed by a sufficient quorum of signatories;
\item
  all deadlines are sufficiently far in the future, and none is too far in the future (see Section~\ref{sect:deadlines});
\item
  protocol version upgrades correctly increment the version number against the current protocol version (see Section~\ref{sect:upgrades});
\item
  all validity conditions that apply to a specific class of proposal are also met.
\end{enumerate}
