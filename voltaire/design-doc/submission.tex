\newpage
\section{Proposal Submission}
\label{sect:submission}

Proposals are submitted by a member of a submitter group.  They are counter-signed by a quorum of submitter keys.\khcomment{Difficult question: who controls registration/de-registration of submitter keys.}\khcomment{How do we ensure that there are always enough submitters in existence.}\khcomment{The quorum may be a protocol parameter.}
No fee is charged for proposal submission.\khcomment{This may need to be discussed.}
A submitter may submit any number of proposals in a single epoch.
\khcomment{This assumes that submitters will not spam the blockchain.}

\subsection{Format}

Each proposal has a header and a body.  % and must be signed\khcomment{Submitting may implicitly sign the proposal?}.

\paragraph{Header.} The header must include:

\begin{verbatim}
"header": {
  "proposal" : ProposalHash,
  "voteby" : Slot,
  "votethreshold" : Threshold,
  "endorseby" : Optional Slot,
  "endorsethreshold" : Optional Threshold,
  "enact" : Epoch,
  "submitter" : KeyHash
}
\end{verbatim}

The \texttt{proposal} field allows the proposal to be tied to a corresponding off-chain proposal (see Appendix~\ref{sect:relating-off-and-on-chain} and Section~\ref{sect:proposalid}).  The \textt{voteby} and \texttt{endorseby} fields specify deadlines.
Votes and endorsements must be received prior to the specified slot if they are to be counted.  The endorsement deadline is optional.
\khcomment{Arguably, to avoid performance issues, tallying should either happen at epoch boundaries or in a separate thread.}
In order to avoid zombie proposals that could disrupt operations, deadlines must be set within a reasonable time period after submission (e.g. within 3 epochs).
Voting and endorsement slots and thresholds are completely independent, so a voting deadline may be set before/after/at the same time as an endorsement deadline.
Deadlines can never be set in the past.
%
The \texttt{votethreshold} and \texttt{endorsethreshold} fields allow specific thresholds to be set for voting and endorsement, respectively.  This allows the type of proposal to be differentiated on a per-proposal basis
(e.g. a protocol version upgrade may require a higher vote threshold than a simple parameter change).
\khcomment{Arguably, this is dangerous and standard or minimum thresholds should be set as protocol parameters.}
%
The \texttt{enact} field specifies when the proposal is to be enacted if it is approved and endorsed.  This will always be in the future.
%
The proposal submitter must belong to the correct submitter group.  \khcomment{Different groups for each kind of proposal?}

The body of the proposal is specific to the proposal type.

\newpage
\paragraph{Parameter Update Body.}  The proposal format is identical to that used for Shelley/Allegra/Mary/Alonzo. \TODO{Check the format.}  Multiple parameters may be changed in a single proposal if required.
Parameters are checked for validity on enactment, rather than on submission, so it is possible to submit a proposal that will change parameters following a future protocol version upgrade, for example.


\begin{verbatim}
"body": {
  "parameter n" : "new value 1",
  ...
  "parameter n" : "new value n"
}
\end{verbatim}

\paragraph{Protocol Version Upgrade Body.}  The format is also identical to that used for Shelley/Allegra/Mary/Alonzo.


\begin{verbatim}
"body": {
  "Major" : Integer,
  "Minor" : Integer,
  "Genesis" : Hash
}
\end{verbatim}

Node software only needs to comply with the new protocol rules.  It does not need to be a specific version, for example, and we do not check a software hash.

\khcomment{I assume that the new set of parameters is encoded in the genesis hash?}

\khcomment{We might also need to include some hash here that can be verified by the system?}

\paragraph{Central Funds Transfer Body.}  The format is also identical to that used for Shelley/Allegra/Mary/Alonzo.
A single proposal may cover multiple funds transfers.  These are enacted in the order they are encountered.
\khcomment{There is a tradeoff here: submit many proposals that may clog up the system, or submit a few.  Even if there are fewer proposals, transaction size limits mean
that a set of transfers (for Catalyst funds, for instance), may  need to broken down into a large number of submission.}

\begin{verbatim}
"body": {
  "from" : Treasury/Reserves,
  "to" : Optional Treasury/Reserves,
  "toAddress" : Optional Address,
  "amount" : Nat
}
\end{verbatim}

Funds may be transferred from either the treasury or the reserves pot, and sent to either an address, or to the treasury/reserves pot.
Transfers from treasury to treasury or from reserves to reserves are not permitted.  All transfers must be of a positive amount (including zero).
Multiple transfers may be made in a single epoch.  This allows for proper accounting, where eg different kinds of transfer must
be authorised by different groups of individual.

Errors in transfers between reserves and treasury, or vice-versa, may be corrected by constructing a reverse transfer that cancels the original error.
This cannot happen for transfers to addresses, of course.  Any errors must be corrected by the owner of the address, who must either explicitly transfer
the funds to reserves or treasury, or else transfer the funds to a holding account. \khcomment{There is no way to transfer back at the moment!}

\subsection{Proposal Signing}

All update and proposals must be signed when they are submitted.  A proposal must be counter-signed by a quorum of signatures using a signing
policy that conforms to the existing \emph{multi-sig} transaction mechanism.  This enables the use of standard transaction witnessing.
% where the quorum is a protocol parameter
The signing policy is then provided as an updatable protocol parameter.  This gives a great deal of flexibility to define and change submission policies.
To reduce the possibility of abuse, the policy must comply with a minimum quorum size should be hard-wired into the protocol.


\khcomment{The obvious approach is to use transaction witnessing and a multi-sig approach, as described here.  That implies a change to the submission process, and also that
  the submitter group is sufficiently small to allow this (I think we calculated n+m=500, where n is the actual number and m is the required number?}
\khcomment{Using multi-sig potentially allows policies to be defined as described above.  This simplifies the system by removing the need for a separate Elector group,
  but is perhaps open to abuse of power?}

\subsection{Proposal Identifiers}
\label{sect:proposalid}

Each proposal has a unique identifier that is used for voting, endorsement and enactment.  It may also be used to refer to the proposal in the off-chain process (eg to provide its
status, encourage voting etc).  At a minimum, uniqueness must be enforced between submission and enactment, but it will be simplest to have full uniqueness, since the blockchain will need to record
details of each proposal indefinitely.

There are three obvious ways to construct an identifier.

\begin{description}
\item
  [Option 1.]
  An explicit identifier that is assigned manually, and is included in the proposal submission.  This could be tied, if desired, directly to the off-chain proposal/discussion.
  Care needs to be taken to ensure uniqueness of any manually assigned proposal identifier.  This is shown above as the \texttt{proposal} field.
\item
  [Option 2.]
  The identifier is constructed by hashing the submitted proposal.  This allows proposals to be identified before submission as well as during voting and enactment.  This property may be
  useful to connect off-chain and on-chain mechanisms for example.  \emph{Collision resistance} is required for the hash. \khcomment{Confirm this.}
\item
  [Option 3.]
  The transaction identifier is used to identify the proposal.  This has the advantage that it is already available on-chain, and is guaranteed to be unique.  However, it cannot be
  referred to prior to on-chain proposal submission.
\end{description}
