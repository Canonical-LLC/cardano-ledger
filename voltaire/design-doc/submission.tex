\newpage
\section{Proposal Submission}
\label{sect:submission}

Proposals are submitted by a member of a submitter group.  They must be counter-signed by a quorum of submitter keys, where the quorum is specified by the \texttt{ProposalQuorum} parameter.
\khcomment{Difficult question: who controls registration/de-registration of submitter keys.}\pkcomment{How about an on-chain vote by ada holders?}\khcomment{That isn't possible without extending the design, of course...  You could include this as an update proposal, of course, but who submits the proposal and how do you avoid the submitter group then vetoing changes?}\khcomment{How do we
ensure that there are always enough submitters in existence.}\pkcomment{We should have an option to reboot this set by a vote from ada holders, in case there are not enough (active) submitters}\khcomment{The
quorum may be a protocol parameter.}\pkcomment{with an enforced sensible range in $(0,1)$}\khcomment{Yes.  I was expecting an integer value, though.  Consider the edge case where there are only a few submitters, or awkward cases where the number of submitters changes. Do you round up or down?}  No fee is charged for proposal
submission.\khcomment{This may need to be discussed.}  A submitter may submit
any number of proposals in a single epoch.
\khcomment{This assumes that submitters are trustworthy and will not collectively spam the blockchain.}
\pkcomment{Depending on how we accumulate the counter signatures (including all of them in the transaction with the proposal, which requires off chain coordination between the submitters, or collecting them in susequent transactions) it might also be possible for a single submitter to spam the chain}
\khcomment{The obvious approach is to use multi-sig transactions, or similar.  That would prevent multiple proposals from spamming the chain [you might be able to resubmit the same proposal, of course].  Requiring multiple transactions would be more problematic.}

\subsection{Format}

Each proposal has a header and a body.  % and must be signed\khcomment{Submitting may implicitly sign the proposal?}.

\paragraph{Header.} The header must include:

\begin{verbatim}
"header": {
  "proposal"         : ProposalHash,
  "voteby"           : Slot,
  "votethreshold"    : Threshold,
  "endorseby"        : Optional Slot,
  "endorsethreshold" : Optional Threshold,
  "enact"            : Epoch,
  "submitter"        : KeyHash
}
\end{verbatim}\pkcomment{Do we need \texttt{Slot}, or \texttt{Epoch}?}\khcomment{You want Slot, because that is what matters for consistent voting [I assume you want the current speed of enactment]}

The \texttt{proposal} field allows the proposal to be tied to a corresponding off-chain proposal (see Appendix~\ref{sect:relating-off-and-on-chain} and Section~\ref{sect:proposalid}).  The \texttt{voteby} and \texttt{endorseby} fields specify deadlines.
Votes and endorsements must be received prior to the specified slot if they are to be counted.  The endorsement deadline is optional.
%\khcomment{Arguably, to avoid performance issues, tallying should either happen at epoch boundaries or in a separate thread.}\pkcomment{Yes, same as for calculating the stake distribution and the rewards}
To avoid performance issues, tallying must be spread over time, eg in a separate thread or using a ``pulsing'' calculation.\pkcomment{Yes, same as for calculating the stake distribution and the rewards}
In order to avoid zombie proposals that could disrupt operations, deadlines must be set within a reasonable time period after submission (e.g. within 3 epochs).
Voting and endorsement slots and thresholds are completely independent, so a voting deadline may be set before/after/at the same time as an endorsement deadline.
Deadlines can never be set in the past.
The deadline for proposal enactment must be later than the  voting and endorsement deadlines, and account for required stability windows.
%
The \texttt{votethreshold} and \texttt{endorsethreshold} fields allow specific thresholds to be set for voting and endorsement, respectively.  This allows the type of proposal to be differentiated on a per-proposal basis
(e.g. a protocol version upgrade may require a higher vote threshold than a simple parameter change).
\khcomment{Arguably, this is dangerous and standard or minimum thresholds should be set as protocol parameters.}
%
The \texttt{enact} field specifies when the proposal is to be enacted if it is approved and endorsed.  This will always be in the future.
%
The proposal submitter must belong to the correct submitter group.  \khcomment{Different groups for each kind of proposal?}

The body of the proposal is specific to the proposal type.

\newpage
\paragraph{Parameter Update Body.}  The proposal format is identical to that used for Shelley/Allegra/Mary/Alonzo. \TODO{Check the concrete format.}  Multiple parameters may be changed in a single proposal if required.
Parameters are checked for validity on enactment, rather than on submission, so it is possible to submit a proposal that will change parameters following a future protocol version upgrade, for example.


\begin{verbatim}
"body": {
  "parameter n" : "new value 1",
  ...
  "parameter n" : "new value n"
}
\end{verbatim}

\paragraph{Protocol Version Upgrade Body.}  The format is slightly changed from that used for Shelley/Allegra/Mary/Alonzo.


\begin{verbatim}
"body": {
  "Major"       : Integer,
  "Minor"       : Integer,
  "Genesis"     : Hash,
  "CodeVersion" : [Hash]
}
\end{verbatim}

The major and minor protocol version numbers identify the new protocol.  The genesis parameter hashes the genesis file, so ensuring that consistent initial protocol parameters are used.
The proposal also includes a list of hashes that can be used to identify one or more reference versions of the node software that implement the new protocol (e.g. as references to a specific git commit).
Node operators are not required to use one of these versions -- any software that follows the protocol rules may be be used.
\khcomment{These could also be hashed in the genesis file?}
% Node software only needs to comply with the new protocol rules.  It does not need to be a specific version, for example, and we do not check a software hash.
\khcomment{I assume that the new set of protocol parameters etc. is encoded in the genesis hash so do not need to be explicitly included here?}

% \khcomment{We might also need to include some hash here that can be verified by the system?} % Dealt woth

\paragraph{Central Funds Transfer Body.}  The format is also identical to that used for Shelley/Allegra/Mary/Alonzo.
A single proposal may cover multiple funds transfers.  These are enacted in the order they are encountered.
\khcomment{There is a tradeoff here: submit many proposals that may clog up the system, or submit a few.  Even if there are fewer proposals, transaction size limits mean
that a set of transfers (for Catalyst funds, for instance), may  need to broken down into a large number of submission.}

\begin{verbatim}
"body": {
  "from"      : "Treasury"/"Reserves",
  "to"        : Optional "Treasury"/"Reserves",
  "toAddress" : Optional Address,
  "amount"    : Nat
}
\end{verbatim}

Funds may be transferred from either the treasury or the reserves, and sent to either an address, or to the treasury/reserves.
Transfers from treasury to treasury or from reserves to reserves are not permitted.  All transfers must be for a positive amount (including zero\pkcomment{Why do we want to allow zero here?})\khcomment{I was assuming that this might be needed for accounting or automation reasons}.
Multiple transfers may be made in a single epoch.  This allows for proper accounting, where e.g. different kinds of transfer must
be authorised by different groups.

Errors in transfers between reserves and treasury, or vice-versa, may be corrected by constructing a reverse transfer that cancels the original error.
This cannot happen for transfers to addresses.  Any errors in such transfers, must be corrected by the owner of the address, who must either explicitly transfer
the funds to reserves or treasury, or else transfer the funds to a holding account. \khcomment{There is no way to transfer back to treasury/reserves at the moment!}

\subsection{Proposal Signing}

All proposals must be signed when they are submitted.  A proposal must be counter-signed by a quorum of signatures using a signing
policy that conforms to the existing \emph{multi-sig} transaction mechanism.  This enables the use of standard transaction witnessing.
% where the quorum is a protocol parameter
The signing policy is then provided as an updatable protocol parameter.  This gives a great deal of flexibility to define and change submission policies.
To reduce the possibility of abuse, the policy must comply with a minimum quorum size, which should be hard-wired into the protocol.


\khcomment{The obvious approach is to use transaction witnessing and a multi-sig approach, as described here.  That implies a change to the submission process, and also that
  the submitter group is sufficiently small to allow this (I think we calculated n+m=500, where n is the actual number and m is the required number?}
\khcomment{Using multi-sig potentially allows policies to be defined as described above.  This simplifies the system by removing the need for a separate Elector group,
  but is perhaps open to abuse of power?}

Note that the process described here intrinsically supports automation.  Signatories can be automated agents if desired rather than individuals.  This also allows integration into a full on-chain voting mechanism in the longer term, as with Priviledge.  The outcome of an off-chain or on-chain vote may be to construct a signed on-chain proposal for subsequent enactment.  Ultimately, if the process is purely on-chain, then the vote outcome could be embedded as the authorisation for the proposal submission without needing to construct or maintain special submitter keys.  This would improve some aspects of security, but would mean that either: i) a proposal would need to be formalised prior to the initial voting round (which might be impractical for e.g. protocol upgrades or some forms of funds transfers); or else ii) delegates would need to confirm that the proposal that was enacted was equivalent to the one that was originally agreed.


\subsection{Proposal Identifiers}
\label{sect:proposalid}

Each proposal has a unique identifier that is used for voting, endorsement, and enactment.  It may also be used to refer to the proposal in the off-chain process (eg to provide its
status, encourage voting, etc).  At a minimum, uniqueness must be enforced between submission and enactment, but it will be simplest to have full uniqueness, since the blockchain will need to record
details of each proposal indefinitely.

There are three obvious ways to construct an identifier.

\begin{description}
\item
  [Option 1.]
  An explicit identifier that is assigned manually, and is included in the proposal submission.  This could be tied, if desired, directly to the off-chain proposal/discussion.
  Care needs to be taken to ensure uniqueness of any manually assigned proposal identifier.  This is shown above as the \texttt{proposal} field.
\item
  [Option 2.]
  The identifier is constructed by hashing the submitted proposal.  This allows proposals to be identified before submission as well as during voting and enactment.  This property may be
  useful to connect off-chain and on-chain mechanisms for example.  \emph{Collision resistance} is required for the hash. \khcomment{Confirm this.}
\item
  [Option 3.]
  The transaction identifier is used to identify the proposal.  This has the advantage that it is already available on-chain, and is guaranteed to be unique.  However, it cannot be
  referred to prior to on-chain proposal submission.
\end{description}

\subsection{Extension to Differentiated Submitter Groups}

This design assumes a single self-perpetuating or elected submitter group.  It
would be possible to differentiate proposals, so that specific kinds of proposal
could be submitted by different groups.  For example, a group might have
authority to submit a proposal that changed specific parameters, that authorised
funds transfers up to some amount, that transferred balances between reserves
and treasury, or between treasury and specific nominated accounts.  The obvious
way to do this would be to embed general Plutus scripts in the submission
authorisation (or to allow Plutus scripts to construct proposals).  This could
involve some changes to ledger rules (including perhaps changes to script
plumbing), so should probably be seen as an extension to the base design, rather
than a core requirement.  \todo{Consider whether a script can be used for
  proposal submission rather than embedded signatures.  Does the two-phase Plutus process cause unwanted delays?}

For such an approach to be feasible, it would be necessary to determine whether
a proposal was permitted to be signed by a specific group (i.e. the proposal
would need to be automatically checked and validated against the group
credentials).  It would also be necessary to set thresholds and quora
differently for different kinds of proposal.  These thresholds would need to be
independently validated through security audit.
